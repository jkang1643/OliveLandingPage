<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Olive - Mediterranean Christian App</title>
  <link rel="stylesheet" href="olive-landing.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    /* Performance optimizations */
    svg {
      will-change: transform;
      transform: translateZ(0); /* Force hardware acceleration */
    }
    
    .animated-element {
      will-change: transform, opacity;
      transform: translateZ(0); /* Force hardware acceleration */
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      overflow-x: hidden;
    }
  </style>
</head>
<body>
  <div class="hero-bg" id="main-content">
    <!-- Animated background SVG layer -->
    <svg id="animated-bg" width="100%" height="100%" viewBox="0 0 800 600" style="position:absolute;top:0;left:0;width:100vw;height:100vh;z-index:0;pointer-events:none;">
      <!-- Soft rays -->
      <g id="bg-rays">
        <line x1="400" y1="300" x2="400" y2="80" stroke="#e9c46a" stroke-width="4" opacity="0.08"/>
        <line x1="400" y1="300" x2="700" y2="120" stroke="#e9c46a" stroke-width="4" opacity="0.06"/>
        <line x1="400" y1="300" x2="100" y2="120" stroke="#e9c46a" stroke-width="4" opacity="0.06"/>
        <line x1="400" y1="300" x2="800" y2="300" stroke="#e9c46a" stroke-width="4" opacity="0.05"/>
        <line x1="400" y1="300" x2="0" y2="300" stroke="#e9c46a" stroke-width="4" opacity="0.05"/>
      </g>
      <!-- Animated ecosystem elements -->
      <!-- Grass is now attached to each flower group below -->
      <!-- Flowers -->
      <g id="island-flowers-north">
        <g id="island-flower-1">
          <path id="grass-2" d="M130,600 Q135,585 140,600" stroke="#A3C585" stroke-width="4" fill="none" opacity="0.18"/>
          <rect x="133.5" y="570" width="3" height="16" fill="#7D945D" opacity="0.18"/>
          <ellipse cx="135" cy="570" rx="6" ry="6" fill="#e9c46a" opacity="0.18"/>
        </g>
        <g id="island-flower-2">
          <path id="grass-4" d="M200,600 Q205,588 210,600" stroke="#A3C585" stroke-width="4" fill="none" opacity="0.18"/>
          <rect x="203.5" y="575" width="3" height="14" fill="#7D945D" opacity="0.18"/>
          <ellipse cx="205" cy="575" rx="5" ry="5" fill="#e9c46a" opacity="0.18"/>
        </g>
        <g id="island-flower-3">
          <path id="grass-5" d="M250,600 Q255,592 260,600" stroke="#A3C585" stroke-width="4" fill="none" opacity="0.18"/>
          <rect x="258.5" y="580" width="3" height="18" fill="#7D945D" opacity="0.18"/>
          <ellipse cx="260" cy="580" rx="7" ry="7" fill="#A3C585" opacity="0.18"/>
        </g>
        <g id="island-flower-4">
          <path id="grass-6" d="M300,600 Q305,590 310,600" stroke="#A3C585" stroke-width="4" fill="none" opacity="0.18"/>
          <rect x="308.5" y="570" width="3" height="16" fill="#7D945D" opacity="0.18"/>
          <ellipse cx="310" cy="570" rx="6" ry="6" fill="#e9c46a" opacity="0.18"/>
        </g>
        <g id="island-flower-5">
          <path id="grass-7" d="M400,600 Q405,590 410,600" stroke="#A3C585" stroke-width="4" fill="none" opacity="0.18"/>
          <rect x="408.5" y="575" width="3" height="14" fill="#7D945D" opacity="0.18"/>
          <ellipse cx="410" cy="575" rx="5" ry="5" fill="#A3C585" opacity="0.18"/>
        </g>
        <g id="island-flower-6">
          <path id="grass-8" d="M600,600 Q605,590 610,600" stroke="#A3C585" stroke-width="4" fill="none" opacity="0.18"/>
          <rect x="603.5" y="580" width="3" height="18" fill="#7D945D" opacity="0.18"/>
          <ellipse cx="605" cy="580" rx="7" ry="7" fill="#e9c46a" opacity="0.18"/>
        </g>
      </g>
      <!-- Bugs/Butterflies -->
      <g id="island-bugs-north">
        <ellipse cx="180" cy="500" rx="2.5" ry="2" fill="#7D945D" opacity="0.18"/>
        <ellipse cx="350" cy="520" rx="2.5" ry="2" fill="#A3C585" opacity="0.18"/>
        <ellipse cx="600" cy="540" rx="2.5" ry="2" fill="#8ba75a" opacity="0.18"/>
        <ellipse cx="700" cy="510" rx="2.5" ry="2" fill="#e9c46a" opacity="0.18"/>
      </g>
      <!-- Bushes -->
      <g id="ecosystem-bushes">
        <ellipse id="bush-1" cx="180" cy="590" rx="18" ry="8" fill="#8ba75a" opacity="0.13"/>
        <ellipse id="bush-2" cx="350" cy="590" rx="22" ry="10" fill="#A3C585" opacity="0.13"/>
        <ellipse id="bush-3" cx="500" cy="590" rx="20" ry="9" fill="#7D945D" opacity="0.13"/>
      </g>
      <!-- Houses -->
      <!-- Add three more island houses at the old ecosystem house positions -->
      <g id="island-houses">
        <g transform="translate(320,500) rotate(-7)">
          <rect x="-8" y="0" width="16" height="12" fill="#fbeab0" opacity="0.18"></rect>
          <polygon points="-8,0 0,-10 8,0" fill="#b48a5a" opacity="0.18"></polygon>
        </g>
        <g transform="translate(480,510) rotate(7)">
          <rect x="-7" y="0" width="14" height="10" fill="#fbeab0" opacity="0.18"></rect>
          <polygon points="-7,0 0,-8 7,0" fill="#b48a5a" opacity="0.18"></polygon>
        </g>
        <g transform="translate(400,470) rotate(0)">
          <rect x="-9" y="0" width="18" height="14" fill="#fbeab0" opacity="0.18"></rect>
          <polygon points="-9,0 0,-12 9,0" fill="#b48a5a" opacity="0.18"></polygon>
        </g>
        <!-- New island houses at the old ecosystem house positions -->
        <g transform="translate(489,577) rotate(-2)">
          <rect x="-8" y="0" width="16" height="12" fill="#fbeab0" opacity="0.18"></rect>
          <polygon points="-8,0 0,-10 8,0" fill="#b48a5a" opacity="0.18"></polygon>
        </g>
        <g transform="translate(578,582) rotate(3)">
          <rect x="-7" y="0" width="14" height="10" fill="#fbeab0" opacity="0.18"></rect>
          <polygon points="-7,0 0,-8 7,0" fill="#b48a5a" opacity="0.18"></polygon>
        </g>
        <g transform="translate(657,586) rotate(-4)">
          <rect x="-9" y="0" width="18" height="14" fill="#fbeab0" opacity="0.18"></rect>
          <polygon points="-9,0 0,-12 9,0" fill="#b48a5a" opacity="0.18"></polygon>
        </g>
      </g>
      <!-- Wind -->
      <g id="ecosystem-wind">
        <path id="wind-1" d="M100,100 Q200,80 300,120 Q400,160 600,100" stroke="#e9c46a" stroke-width="4" fill="none" opacity="0.08"/>
        <path id="wind-2" d="M200,200 Q300,180 400,220 Q500,260 700,200" stroke="#e9c46a" stroke-width="4" fill="none" opacity="0.08"/>
      </g>
      <!-- Birds -->
      <g id="ecosystem-birds">
        <path id="bird-1" d="M150,80 Q160,70 170,80" stroke="#7D945D" stroke-width="3" fill="none" opacity="0.18"/>
        <path id="bird-2" d="M300,60 Q310,50 320,60" stroke="#A3C585" stroke-width="3" fill="none" opacity="0.18"/>
        <path id="bird-3" d="M500,90 Q510,80 520,90" stroke="#8ba75a" stroke-width="3" fill="none" opacity="0.18"/>
      </g>
      <!-- Mini-world Mediterranean island base -->
      <ellipse id="island-base" cx="400" cy="500" rx="340" ry="120" fill="#b7d3a8" opacity="0.18" transform="rotate(-8 400 500)"/>
      <!-- Winding Mediterranean path/road -->
      <path id="island-path" d="M250,540 Q350,520 400,500 Q450,480 550,520" stroke="#e9c46a" stroke-width="12" fill="none" opacity="0.13"/>
      <!-- Mediterranean trees, houses, and plants arranged around the island -->
      <g id="island-trees">
        <g transform="translate(270,470) rotate(-10)">
          <ellipse cx="0" cy="0" rx="18" ry="28" fill="#7D945D" opacity="0.18"/>
          <rect x="-4" y="20" width="8" height="18" fill="#b48a5a" opacity="0.18"/>
        </g>
        <g transform="translate(340,440) rotate(-5)">
          <ellipse cx="0" cy="0" rx="14" ry="22" fill="#A3C585" opacity="0.18"/>
          <rect x="-3" y="14" width="6" height="14" fill="#b48a5a" opacity="0.18"/>
        </g>
        <g transform="translate(420,430) rotate(0)">
          <ellipse cx="0" cy="0" rx="16" ry="24" fill="#8ba75a" opacity="0.18"/>
          <rect x="-3" y="16" width="6" height="16" fill="#b48a5a" opacity="0.18"/>
        </g>
        <g transform="translate(500,450) rotate(8)">
          <ellipse cx="0" cy="0" rx="15" ry="20" fill="#A3C585" opacity="0.18"/>
          <rect x="-3" y="12" width="6" height="14" fill="#b48a5a" opacity="0.18"/>
        </g>
        <g transform="translate(570,480) rotate(12)">
          <ellipse cx="0" cy="0" rx="18" ry="28" fill="#7D945D" opacity="0.18"/>
          <rect x="-4" y="20" width="8" height="18" fill="#b48a5a" opacity="0.18"/>
        </g>
      </g>
      <g id="island-houses">
        <g transform="translate(320,500) rotate(-7)">
          <rect x="-8" y="0" width="16" height="12" fill="#fbeab0" opacity="0.18"/>
          <polygon points="-8,0 0,-10 8,0" fill="#b48a5a" opacity="0.18"/>
        </g>
        <g transform="translate(480,510) rotate(7)">
          <rect x="-7" y="0" width="14" height="10" fill="#fbeab0" opacity="0.18"/>
          <polygon points="-7,0 0,-8 7,0" fill="#b48a5a" opacity="0.18"/>
        </g>
        <g transform="translate(400,470) rotate(0)">
          <rect x="-9" y="0" width="18" height="14" fill="#fbeab0" opacity="0.18"/>
          <polygon points="-9,0 0,-12 9,0" fill="#b48a5a" opacity="0.18"/>
        </g>
      </g>
      <g id="island-plants">
        <ellipse cx="300" cy="520" rx="10" ry="5" fill="#A3C585" opacity="0.13"/>
        <ellipse cx="370" cy="510" rx="8" ry="4" fill="#8ba75a" opacity="0.13"/>
        <ellipse cx="450" cy="515" rx="9" ry="5" fill="#A3C585" opacity="0.13"/>
        <ellipse cx="520" cy="525" rx="10" ry="5" fill="#8ba75a" opacity="0.13"/>
      </g>
      <!-- Sun and clouds in dynamic, layered positions -->
      <g id="island-sky">
        <ellipse id="island-sun" cx="650" cy="80" rx="38" ry="38" fill="#ffe5a0" opacity="0.18"/>
        <ellipse id="cloud-1" cx="200" cy="100" rx="40" ry="18" fill="#fff" opacity="0.10"/>
        <ellipse id="cloud-2" cx="500" cy="60" rx="30" ry="14" fill="#fff" opacity="0.10"/>
        <ellipse id="cloud-3" cx="600" cy="120" rx="28" ry="12" fill="#fff" opacity="0.10"/>
      </g>
      <!-- Remove trees above the blue area (top half) -->
      <!-- Only keep trees in the lower half/island area -->
      <!-- Fluffy white clouds in the blue area (top half) -->
      <g id="sky-clouds">
        <ellipse id="cloud-a" cx="180" cy="90" rx="48" ry="20" fill="#fff" opacity="0.18"/>
        <ellipse id="cloud-b" cx="350" cy="60" rx="38" ry="16" fill="#fff" opacity="0.15"/>
        <ellipse id="cloud-c" cx="600" cy="110" rx="42" ry="18" fill="#fff" opacity="0.16"/>
        <ellipse id="cloud-d" cx="500" cy="80" rx="30" ry="12" fill="#fff" opacity="0.13"/>
      </g>
    </svg>
    <header class="header">
      <span class="logo">Olive</span>
    </header>
    <main class="hero-content" style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
      <div id="olive-logo-container" style="height: 120px; width: 120px; position: relative; display: flex; align-items: center; justify-content: center;">
        <svg id="olive-logo" class="olive-logo" width="120" height="120" viewBox="0 0 120 120" style="display:block;position:relative;z-index:2;">
          <ellipse id="olive-body" cx="60" cy="65" rx="38" ry="52" fill="#7D945D"></ellipse>
          <ellipse id="olive-highlight" cx="50" cy="50" rx="12" ry="18" fill="#b7d3a8" opacity="0.45"></ellipse>
          <rect id="olive-stem" x="56" y="18" width="8" height="22" rx="4" fill="#4d5e3a"></rect>
        </svg>
      </div>
      <h1 class="hero-title" style="text-align:center;">The Leader in Website Creation</h1>
      <p class="hero-subtitle" style="text-align:center;">A new way to connect, reflect, and grow in faith.</p>
      <button class="cta-btn" style="display:block;margin:0 auto 2rem auto;">Start Now</button>
    </main>
  </div> <!-- end of #main-content -->
  <section class="spacer" style="width: 100vw; height: 100vh; background: linear-gradient(to bottom, #b7d3a8 0%, #b3d8ef 100%);"></section>
  <section class="spacer" style="width: 100vw; height: 100vh; background: linear-gradient(to bottom, #b3d8ef 0%, #b7d3a8 50%, #b3d8ef 100%);"></section>
  <section class="spacer" style="width: 100vw; height: 100vh; background: linear-gradient(to bottom, #b3d8ef 0%, #b7d3a8 50%, #b3d8ef 100%);"></section>
    <!-- Subtle background rays -->
    <svg class="background-rays" width="100%" height="100%" viewBox="0 0 800 600" style="position:absolute;top:0;left:0;z-index:0;pointer-events:none;">
      <g id="rays-group">
        <line x1="400" y1="300" x2="400" y2="0" stroke="#e9c46a" stroke-width="2" opacity="0.12"/>
        <line x1="400" y1="300" x2="700" y2="100" stroke="#e9c46a" stroke-width="2" opacity="0.10"/>
        <line x1="400" y1="300" x2="100" y2="100" stroke="#e9c46a" stroke-width="2" opacity="0.10"/>
        <line x1="400" y1="300" x2="800" y2="300" stroke="#e9c46a" stroke-width="2" opacity="0.08"/>
        <line x1="400" y1="300" x2="0" y2="300" stroke="#e9c46a" stroke-width="2" opacity="0.08"/>
      </g>
    </svg>
  </div>

  <script>
    // Professional Animation Management System
    class AnimationManager {
      constructor() {
        this.animations = new Map();
        this.isInitialized = false;
        this.performanceMode = this.detectPerformanceMode();
      }
      
      detectPerformanceMode() {
        // Detect device performance capabilities
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        if (!gl) return 'low';
        
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        if (debugInfo) {
          const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
          if (renderer.includes('Intel') || renderer.includes('Integrated')) {
            return 'low';
          }
        }
        return 'high';
      }
      
      createAnimation(id, config) {
        // Clean up existing animation if it exists
        this.destroyAnimation(id);
        
        // Adjust config based on performance mode
        if (this.performanceMode === 'low') {
          config.duration = config.duration * 1.5; // Slower animations
          config.delay = (config.delay || 0) * 1.5; // More spacing
        }
        
        const animation = anime(config);
        this.animations.set(id, animation);
        return animation;
      }
      
      destroyAnimation(id) {
        const animation = this.animations.get(id);
        if (animation) {
          animation.pause();
          animation.remove = () => {}; // Prevent memory leaks
          this.animations.delete(id);
        }
      }
      
      destroyAllAnimations() {
        this.animations.forEach((animation, id) => {
          this.destroyAnimation(id);
        });
      }
      
      pauseAllAnimations() {
        this.animations.forEach(animation => {
          animation.pause();
        });
      }
      
      resumeAllAnimations() {
        this.animations.forEach(animation => {
          animation.play();
        });
      }
    }
    
    // Global animation manager
    const animationManager = new AnimationManager();
    
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize animation manager
      animationManager.isInitialized = true;
      
      // Forever background animations with proper management
      ['#leaf1', '#leaf2', '#leaf3', '#leaf4'].forEach((id, index) => {
        animationManager.createAnimation(`leaf-${index}`, {
          targets: id,
          translateY: [0, -30 + (index * 10), 0],
          translateX: [0, 20 - (index * 5), 0],
          duration: 9000 + (index * 1000),
        direction: 'alternate',
        easing: 'easeInOutSine',
        loop: true
      });
      });
      
      animationManager.createAnimation('bg-rays', {
        targets: '#bg-rays',
        rotate: [0, 12, -8, 0],
        duration: 22000,
        easing: 'easeInOutSine',
        loop: true
      });
      
      // Cloud animations (optimized for performance)
      animationManager.createAnimation('cloud-1', {
        targets: '#cloud-1',
        translateX: [0, 100, 0],
        opacity: [0.18, 1, 0.18],
        duration: 24000,
        direction: 'alternate',
        easing: 'easeInOutSine',
        loop: true,
        delay: 0
      });
      
      animationManager.createAnimation('cloud-2', {
        targets: '#cloud-2',
        translateX: [0, -80, 0],
        opacity: [0.18, 1, 0.18],
        duration: 24000,
        direction: 'alternate',
        easing: 'easeInOutSine',
        loop: true,
        delay: 0
      });
      
      animationManager.createAnimation('cloud-3', {
        targets: '#cloud-3',
        translateX: [0, 60, 0],
        opacity: [0.18, 1, 0.18],
        duration: 24000,
        direction: 'alternate',
        easing: 'easeInOutSine',
        loop: true,
        delay: 0
      });
      
      // Batch create grass animations
      for (let i = 1; i <= 8; i++) {
        animationManager.createAnimation(`grass-${i}`, {
          targets: `#grass-${i}`,
          translateY: [0, -30, 0],
          opacity: [0.18, 1, 0.18],
          duration: 24000,
          direction: 'alternate',
          easing: 'easeInOutSine',
          loop: true,
          delay: 0
        });
      }
      
      // Batch create flower animations
      for (let i = 1; i <= 6; i++) {
        animationManager.createAnimation(`island-flower-${i}`, {
          targets: `#island-flower-${i}`,
          scale: [1, 1.08, 1],
          rotate: [0, 4, -4, 0],
          translateY: [0, -2, 0],
          opacity: [0.18, 1, 0.18],
          duration: 24000,
          direction: 'alternate',
          easing: 'easeInOutSine',
          loop: true,
          delay: 0
        });
      }
      
      // Batch create bug animations
      const islandBugNorthEls = document.querySelectorAll('#island-bugs-north ellipse');
      islandBugNorthEls.forEach((el, i) => {
        animationManager.createAnimation(`bug-${i}`, {
          targets: el,
          rotate: [0, 8, -8, 0],
          translateX: [0, 2, 0],
          translateY: [0, -2, 0],
          duration: 24000,
          direction: 'alternate',
          easing: 'easeInOutSine',
          loop: true,
          delay: 0
        });
      });
      
      // Batch create bush animations
      for (let i = 1; i <= 3; i++) {
        animationManager.createAnimation(`bush-${i}`, {
          targets: `#bush-${i}`,
          scale: [1, 1.0125, 1],
          opacity: [0.13, 1, 0.13],
          duration: 24000,
          direction: 'alternate',
          easing: 'easeInOutSine',
          loop: true,
          delay: 0
        });
      }
      
      // Batch create ecosystem house animations
      for (let i = 1; i <= 3; i++) {
        animationManager.createAnimation(`ecosystem-house-${i}`, {
          targets: `#house-${i} rect, #house-${i} polygon`,
          scale: [1, 1.04, 1],
          rotate: [0, 3, -3, 0],
          translateY: [0, -2, 0],
          opacity: [0.18, 1, 0.18],
          duration: 24000,
          direction: 'alternate',
          easing: 'easeInOutSine',
          loop: true,
          delay: 0
        });
      }
      
      // Wind animations
      for (let i = 1; i <= 2; i++) {
        animationManager.createAnimation(`wind-${i}`, {
          targets: `#wind-${i}`,
          strokeDashoffset: [anime.setDashoffset, 0],
          duration: 24000,
          direction: 'alternate',
          easing: 'easeInOutSine',
          loop: true,
          delay: 0
        });
      }
      
      // Bird animations - fly in and out of frame naturally with wing flapping
      animationManager.createAnimation('bird-1', {
        targets: '#bird-1',
        translateX: [-100, 900],
        translateY: [0, -20, 10, -15, 0],
        opacity: [0, 0.8, 0.8, 0.8, 0],
        scale: [0.8, 1, 1, 1, 0.8],
        scaleY: [0.6, 1.2, 0.6, 1.2, 0.6], // Wing flapping effect
        duration: 18000,
        easing: 'easeInOutSine',
        loop: true,
        delay: 0
      });
      
      animationManager.createAnimation('bird-2', {
        targets: '#bird-2',
        translateX: [-100, 900],
        translateY: [0, -15, 15, -10, 0],
        opacity: [0, 0.8, 0.8, 0.8, 0],
        scale: [0.8, 1, 1, 1, 0.8],
        scaleY: [0.5, 1.3, 0.5, 1.3, 0.5], // Wing flapping effect
        duration: 20000,
        easing: 'easeInOutSine',
        loop: true,
        delay: 0
      });
      
      animationManager.createAnimation('bird-3', {
        targets: '#bird-3',
        translateX: [-100, 900],
        translateY: [0, -25, 5, -20, 0],
        opacity: [0, 0.8, 0.8, 0.8, 0],
        scale: [0.8, 1, 1, 1, 0.8],
        scaleY: [0.7, 1.1, 0.7, 1.1, 0.7], // Wing flapping effect
        duration: 16000,
        easing: 'easeInOutSine',
        loop: true,
        delay: 0
      });
      
      // Island sun animation
      animationManager.createAnimation('island-sun', {
        targets: '#island-sun',
        scale: [1, 1.02, 1],
        duration: 24000,
        direction: 'alternate',
        easing: 'easeInOutSine',
        loop: true,
        delay: 0
      });
      
      // Batch create tree animations
      for (let i = 1; i <= 5; i++) {
        animationManager.createAnimation(`tree-ellipse-${i}`, {
          targets: `#island-trees g:nth-child(${i}) ellipse`,
          scale: [1, 1.045, 1],
          rotate: [0, 4, -4, 0],
          translateY: [0, -2, 0],
          duration: 24000,
          direction: 'alternate',
          easing: 'easeInOutSine',
          loop: true,
          delay: 0
        });
        
        animationManager.createAnimation(`tree-rect-${i}`, {
          targets: `#island-trees g:nth-child(${i}) rect`,
          scaleY: [1, 1.03, 1],
          rotate: [0, 2, -2, 0],
          translateY: [0, -1, 0],
          duration: 24000,
          direction: 'alternate',
          easing: 'easeInOutSine',
          loop: true,
          delay: 0
        });
      }
      
      // Batch create house animations
      for (let i = 1; i <= 3; i++) {
        animationManager.createAnimation(`island-house-${i}`, {
          targets: `#island-houses g:nth-child(${i}) rect, #island-houses g:nth-child(${i}) polygon`,
          scale: [1, 1.03, 1],
          duration: 24000,
          direction: 'alternate',
          easing: 'easeInOutSine',
          loop: true,
          delay: 0
        });
      }
      
      // Batch create plant animations
      for (let i = 1; i <= 4; i++) {
        animationManager.createAnimation(`plant-${i}`, {
          targets: `#island-plants ellipse:nth-child(${i})`,
          scale: [1, 1.02, 1],
          duration: 24000,
          direction: 'alternate',
          easing: 'easeInOutSine',
          loop: true,
          delay: 0
        });
      }
      
      // Background group animation
      animationManager.createAnimation('animated-bg', {
        targets: '#animated-bg',
        rotate: [0, 3, -3, 0],
        translateY: [0, -6, 0, 6, 0],
        duration: 24000,
        easing: 'easeInOutSine',
        direction: 'alternate',
        loop: true,
        delay: 0
      });
      
      // Animate olive after page load
      const olive = document.getElementById('olive-logo');
      if (olive) {
        olive.style.opacity = '0';
        olive.style.transformOrigin = '60px 60px';
        olive.style.transform = 'scale(0.7) translateY(30px)';
        
        animationManager.createAnimation('olive-entrance', {
          targets: olive,
          opacity: [0, 1],
          scale: [0.7, 1.08, 1],
          translateY: [30, -10, 0],
          easing: 'easeOutElastic(1, .7)',
          duration: 1200,
          begin: function() {
            setupOliveScrollAnimation();
          },
          complete: function() {
            // Animate hero content after olive is ready
            animationManager.createAnimation('hero-content', {
              targets: ['.hero-title', '.hero-subtitle', '.cta-btn'],
              opacity: [0, 1],
              translateY: [40, 0],
              delay: anime.stagger(200, {start: 100}),
              duration: 900,
              easing: 'easeOutExpo',
            });
          }
        });
      }
      
      // Parallax effect for mountain and sunrise
      const parallaxHero = document.querySelector('.parallax-hero');
      const mountain = document.getElementById('mountain-svg');
      const sunrise = document.getElementById('sunrise');
      
      if (parallaxHero && mountain && sunrise) {
        let parallaxAnimation = null;
        
        parallaxHero.addEventListener('mousemove', (e) => {
          if (parallaxAnimation) {
            parallaxAnimation.pause();
          }
          
          const rect = parallaxHero.getBoundingClientRect();
          const x = (e.clientX - rect.left) / rect.width - 0.5;
          const y = (e.clientY - rect.top) / rect.height - 0.5;
          
          parallaxAnimation = anime({
            targets: [mountain, sunrise],
            translateX: [x * 20, x * 40],
            translateY: [y * 10, y * 20],
            duration: 100,
            easing: 'easeOutQuad'
          });
        });
        
        parallaxHero.addEventListener('mouseleave', () => {
          if (parallaxAnimation) {
            parallaxAnimation.pause();
          }
          
          anime({
            targets: [mountain, sunrise],
            translateX: 0,
            translateY: 0,
            duration: 300,
            easing: 'easeOutQuad'
          });
        });
      }
      
      // Sun hover pop and rise effect
      const sun = document.getElementById('sun-ellipse');
      let sunHoverAnim = null;
      
      if (sun) {
        sun.addEventListener('mouseenter', () => {
          if (sunHoverAnim) sunHoverAnim.pause();
          sunHoverAnim = animationManager.createAnimation('sun-hover', {
            targets: sun,
            scale: 1.15,
            cy: 60,
            duration: 500,
            easing: 'easeOutBack',
          });
        });
        
        sun.addEventListener('mouseleave', () => {
          if (sunHoverAnim) sunHoverAnim.pause();
          sunHoverAnim = animationManager.createAnimation('sun-leave', {
            targets: sun,
            scale: 1,
            cy: 90,
            duration: 500,
            easing: 'easeOutBack',
          });
        });
      }
      
      // Performance monitoring
      let frameCount = 0;
      let lastTime = performance.now();
      
      function monitorPerformance() {
        frameCount++;
        const currentTime = performance.now();
        
        if (currentTime - lastTime >= 1000) {
          const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
          
          if (fps < 30) {
            console.warn(`Low FPS detected: ${fps}. Pausing some animations.`);
            // Pause some background animations to improve performance
            animationManager.pauseAllAnimations();
            setTimeout(() => animationManager.resumeAllAnimations(), 1000);
          }
          
          frameCount = 0;
          lastTime = currentTime;
        }
        
        requestAnimationFrame(monitorPerformance);
      }
      
      // Start performance monitoring
      requestAnimationFrame(monitorPerformance);
    });
  </script>
  <script>
    // Setup olive scroll animation function
    let oliveScrollHandlerAttached = false;
    let oliveAnimationState = {
      isSticky: false,
      animationComplete: false,
      lastScrollY: 0,
      initialX: 0,
      initialY: 0,
      scrollEnd: 0
    };
    
    function setupOliveScrollAnimation() {
      if (oliveScrollHandlerAttached) {
        console.log('[OliveScroll] Scroll handler already attached, skipping.');
        return;
      }
      oliveScrollHandlerAttached = true;
      console.log('[OliveScroll] Attaching scroll handler.');
      
      const olive = document.getElementById('olive-logo');
      if (!olive) {
        console.error('Olive logo SVG not found for scroll animation!');
        return;
      }
      
      // Add will-change for smoother transform animation
      olive.style.willChange = 'transform';
      console.log('Setting up olive scroll animation...');
      
      // Wait for next frame to ensure proper positioning
      requestAnimationFrame(() => {
        // Get initial position of olive relative to viewport
        const oliveContainer = document.getElementById('olive-logo-container');
        const oliveRect = oliveContainer.getBoundingClientRect();
        oliveAnimationState.initialX = oliveRect.left;
        oliveAnimationState.initialY = oliveRect.top;
        
        // Helper: create/remove placeholder
        function setPlaceholder(visible) {
          let ph = document.getElementById('olive-placeholder');
          if (visible) {
            if (!ph) {
              ph = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
              ph.setAttribute('id', 'olive-placeholder');
              ph.setAttribute('width', '120');
              ph.setAttribute('height', '120');
              ph.style.visibility = 'hidden';
              oliveContainer.appendChild(ph);
            }
          } else {
            if (ph) ph.remove();
          }
        }
        
        // Scroll-based animation (sticky to viewport)
        oliveAnimationState.scrollEnd = document.body.scrollHeight - window.innerHeight;
        
        // --- Optimization: throttle scroll handler ---
        let ticking = false;
        let resizeTicking = false;
        
        function animateOliveOnScroll() {
          const scrollY = window.scrollY;
          
          // Skip if scroll position hasn't changed significantly
          if (Math.abs(scrollY - oliveAnimationState.lastScrollY) < 1) {
            return;
          }
          
          oliveAnimationState.lastScrollY = scrollY;
          const progress = Math.min(Math.max(scrollY / oliveAnimationState.scrollEnd, 0), 1);
          
          // Reset state if we're at the very top (fresh start)
          if (scrollY <= 10) {
            if (oliveAnimationState.isSticky || oliveAnimationState.animationComplete) {
              oliveAnimationState.isSticky = false;
              oliveAnimationState.animationComplete = false;
              oliveAnimationState.lastScrollY = 0;
            setPlaceholder(false);
            oliveContainer.appendChild(olive);
            olive.style.position = 'relative';
            olive.style.top = 'auto';
            olive.style.left = 'auto';
            olive.style.zIndex = 'auto';
            olive.style.pointerEvents = 'auto';
            olive.style.width = '';
            olive.style.height = '';
            olive.style.transform = '';
            olive.style.opacity = '1';
              console.log('Olive fully reset at top');
              return;
            }
          }
          
          // Start sticky behavior when olive reaches top of viewport
          if (scrollY > 100 && !oliveAnimationState.isSticky) {
            oliveAnimationState.isSticky = true;
            setPlaceholder(true);
            olive.style.position = 'fixed';
            olive.style.top = '20px';
            olive.style.left = '50%';
            olive.style.transform = 'translateX(-50%)';
            olive.style.zIndex = '1000';
            olive.style.pointerEvents = 'none';
            olive.style.width = '120px';
            olive.style.height = '120px';
            console.log('Olive became sticky');
          }
          
          // Animate olive based on scroll progress
          if (oliveAnimationState.isSticky) {
            const scale = 1 - (progress * 0.3); // Scale down to 70%
            const opacity = 1 - (progress * 0.5); // Fade to 50%
            const translateY = progress * 50; // Move down
            const rotate = progress * 360; // Full 360° rotation
            
            olive.style.transform = `translateX(-50%) scale(${scale}) translateY(${translateY}px) rotate(${rotate}deg)`;
            olive.style.opacity = opacity;
            
            // Complete animation at bottom
            if (progress >= 0.99 && !oliveAnimationState.animationComplete) {
              oliveAnimationState.animationComplete = true;
              olive.style.opacity = '0';
              olive.style.transform = 'translateX(-50%) scale(0.7) translateY(50px) rotate(360deg)';
              console.log('Olive animation completed');
            }
          }
        }
        
        // Throttled scroll handler
        function throttledScrollHandler() {
          if (!ticking) {
            requestAnimationFrame(() => {
              animateOliveOnScroll();
              ticking = false;
            });
            ticking = true;
          }
        }
        
        // Throttled resize handler
        function throttledResizeHandler() {
          if (!resizeTicking) {
            requestAnimationFrame(() => {
              oliveAnimationState.scrollEnd = document.body.scrollHeight - window.innerHeight;
              resizeTicking = false;
            });
            resizeTicking = true;
          }
        }
        
        // Attach event listeners
        window.addEventListener('scroll', throttledScrollHandler, { passive: true });
        window.addEventListener('resize', throttledResizeHandler, { passive: true });
        
        // Cleanup function
        window.cleanupOliveScroll = function() {
          window.removeEventListener('scroll', throttledScrollHandler);
          window.removeEventListener('resize', throttledResizeHandler);
          oliveScrollHandlerAttached = false;
          console.log('[OliveScroll] Cleanup completed');
        };
      });
    }
  </script>
</body>
</html> 